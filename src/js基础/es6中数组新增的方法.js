/*
 * @Description:
 * @Author: Tulandbla
 * @GitHubUserName: 232295311@qq.com
 */

//1. Array.find--------------------------------------------------------------------------------
/* 它的参数是一个回调函数，对所有数组成员依次执行该回调函数。
 * 直到找出第一个返回值为true的成员，然后返回该成员。
 * 如果没有符合条件的成员，则返回undefined。*/
let arr = [10, 20, 30];
let firstItem = arr.find((item, index, Arr) => {
  return item > 15;
});
console.log(firstItem); //20

//2. Array.findIndex---------------------------------------------------------------------------
/* 与Array.find类似。
 * 返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。*/
let firstIndex = arr.findIndex((item, index, Arr) => {
  return item > 15;
});
console.log(firstIndex); //1

//3.Array.flat()用于拉平嵌套的数组[推荐-超级好用]------------------------------------------------
/* 数组的成员有时还是数组，Array.flat()用于将嵌套的数组“拉平”，变成一维的数组。
 * 该方法返回一个新数组，对原数据没有影响。
 * flat()默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组,
 * 可以将flat()方法的参数写成一个整数，表示想要拉平的层数，默认为1。
 */

let arr2 = [1, 2, [3, [4, 5]]].flat();
// 上面代码中，表示想要拉平的层数，默认为1
console.log(arr2); // [1, 2, 3, [4, 5]]

let arr3 = [1, 2, [3, [4, 5]]].flat(2);
// 上面代码中，flat()的参数为2，表示要“拉平”两层的嵌套数组。
console.log(arr3); // [1, 2, 3, 4, 5]

//如果不管有多少层嵌套，都要转成一维数组，可以用Infinity关键字作为参数。
let arr4 = [1, [2, [3, [4, 5]]]].flat(Infinity);
console.log(arr4); // [1, 2, 3, 4, 5]

//如果原数组有空位，flat()方法会跳过空位。空位将会消失
console.log([1, 2, , 4, 5].flat()); // [1, 2, 4, 5]

// 4.Array.at()返回对应下标的值[超级好用] --------------------------------------------------------
/**
 * 我们都知道JavaScript不支持数组索引值为负索引。
 * 那么想要表示数组的最后一个成员，不能写成arr[-1]，只能使用arr[arr.length - 1]。
 * 为了解决负索引这个问题，es6中为数组实例增加了at()方法，接受一个整数作为参数。
 * 返回对应位置的成员,支持负索引。
 * 这个方法不仅可用于数组， 也可用于字符串和类型数组（ TypedArray）。
 * 如果参数位置超出了数组范围，at()返回undefined。
 */
const arr5 = [100, 120, 18, 130, 4];
console.log(arr5.at(1)); //120
console.log(arr5.at(-1)); //4
console.log(arr5.at(-5)); //100
console.log(arr5.at(-6)); //undefined

//5.Array.from() -------------------------------------------------------- -----------------------
/**
 * 一个类数组的对象，Array.from将它转为真正的数组。
 * 需要注意的是:这个类数组的对象必须要有length属性才可以，转为数组。
 * 否则将会转为为一个空数组
 */
let arr6 = {
  0: "a",
  1: "b",
  2: "c",
  length: 3,
};

// ES5的写法
var arr7 = [].slice.call(arr6); // ['a', 'b', 'c']
console.log(arr7);
// ES6的写法
let arr8 = Array.from(arr6); // ['a', 'b', 'c']
console.log(arr8);

//当没有类似数组的对象没有length属性
let arr9 = {
  0: "a",
  1: "b",
  2: "c",
};
//此时返回的是一个空数组
console.log(Array.from(arr9)); // []

//6.Array.of()方法用于将【一组数值】转换为数组. --------------------------------------------------------
//主要目的是为了代替 new Array() 传递一个参数和多个参数时，逻辑不一致。和 Array.fill()
const a = Array.of(10, 20, 26, 38);
console.log(a); // [10, 20, 26, 38]

const b = Array.of(3).length;
console.log(b); // 1

//Array.of()可以用以下的代码模拟实现:
function ArrayOf() {
  return [].slice.call(arguments);
}

//7.Array.prototype.includes----------------------------------------------------------------------------
// 方法返回一个布尔值，表示某个数组是否包含给定的值。
// 与字符串的includes方法类似。ES2016 引入了该方法。
const arr10 = [100, 200, 300];
console.log(arr10.includes("100")); //false
console.log(arr10.includes(100)); //true
//没有该方法之前，我们使用数组的indexOf方法，检查是否包含某个值。
if (arr10.indexOf("100") !== -1) {
  // 有这个值
}
/*indexOf方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，
所以要去比较是否不等于-1，表达起来不够直观。
二是，它内部使用严格相等运算符（===）进行判断，这会导致对NaN的误判。
*/
console.log([NaN].indexOf(NaN)); // -1

//includes使用的是不一样的判断算法，所以没有这个问题。
console.log([NaN].includes(NaN)); // true

//8.数组实例的entries()，keys() 和 values()。----------------------------------------------------------------
//9.数组实例的copywithin().----------------------------------------------------------------
/**
 * 在当前数组内部将指定位置的成员复制到其他位置，然后返回当前数组，会改变原数组
 * 接收三个参数：
 * 1、target(必需) 从该位置开始替换数据
 * 2、start(可选) 从该位置开始读取数据，默认为0，如果为负数，则表示到数
 * 3、end(可选) 到该位置前停止读取数据，默认等于数组长度。如果是负数，表示到数
 * 三个参数都应该是数字，如果不是，会自动转为数值
 */
