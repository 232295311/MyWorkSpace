/**
 * 闭包应用场景
 * 答：最常见的是函数封装的时候，再就是在使用定时器的时候，
 * 即：当我们需要在模块中定义一些变量，并希望这些变量一直保存在内存中但又不会 “污染” 全局的变量时，就可以用闭包来定义这个模块。
 * 它的最大用处有 两个，一个是它可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中
 */

/** 假设有这样一组代码，我想把它封装成模块, 不污染全局环境并且保留两个函数的功能
let a = 10;
let b = 20;
function add() {
  return a + b;
}
function subtract() {
  return a - b;
}
add();
subtract()
*/
const modules = (() => {
  let a = 10;
  let b = 20;
  function add() {
    return a + b;
  }
  function subtract() {
    return a - b;
  }
  return {
    add,
    subtract,
  };
})(); //上面就是一个闭包函数
const { add, subtract } = modules;
console.log(add());
console.log(subtract());

/*
问题4：闭包的优缺点
优点：
① 减少全局变量；
② 减少传递函数的参数量；
③ 封装；

缺点：
① 使用闭包会占有内存资源，过多的使用闭包会导致内存溢出等

问题5：内存泄漏，解决方法
答：简单的说就是把那些不需要的变量，但是垃圾回收又收不走的的那些赋值为null，然后让垃圾回收走


问题6：如何使用
答：
1.定义外层函数，封装被保护的局部变量。
2.定义内层函数，执行对外部函数变量的操作。
3.外层函数返回内层函数的对象，并且外层函数被调用，结果保存在一个全局的变量中。
*/
